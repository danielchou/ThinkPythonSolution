# -*- coding: utf-8 -*-
# 從 quizzes.ipynb 轉換而來
# 使用 ipynb_to_py.py 腳本自動轉換

# # 標題
# 第一章
#
# ## 測驗類型
# 形成性測驗 (旨在幫助學習和理解，而非正式評分)

# ### 問題
# 以下哪種型別用來表示帶有小數部分的數字？
# - [ ] `int` (整數)
# - [ ] `real` (實數)
# - [ ] `string` (字串)
# - [X] `float` (浮點數)
#
#
# ### 理由
# - `int` 型別的值只能是整數。
# - Python 沒有叫做 `real` 的型別。
# - `string` 型別的值包含一串字元。
# - `float` 型別的值表示浮點數，它可以有小數部分。

# ### 問題
# 以下哪個是合法的表達式？
#
# - [ ] `'1' / '2'`
# - [ ] `'1' * '2'`
# - [ ] `'1' / 2`
# - [X] `'1' * 2`
#
#
# ### 理由
# - 除法運算子不能用在字串上。
# - 使用乘法運算子時，第一個值可以是字串，但第二個不能是字串 (如果第一個是字串，第二個必須是整數表示重複次數)。
# - 除法運算子不能用在字串上。
# - 當第一個運算元是字串時，乘法運算子會重複該字串，所以結果是 `'11'`。

# ### 問題
# 在像加法或乘法這樣的數學運算中，任何被使用的值的通用詞是什麼？
#
# - [ ] term (項)
# - [ ] factor (因數/因子)
# - [ ] divisor (除數)
# - [X] operand (運算元/操作數)
#
# ### 理由
# - "term" (項) 是用於加法的值，但它不是任何運算中所用值的通用詞。
# - "factor" (因數/因子) 是用於乘法的值，但它不是任何運算中所用值的通用詞。
# - "divisor" (除數) 是用於除法的值之一，但它不是任何運算中所用值的通用詞。
# - "operand" (運算元/操作數) 是運算中使用的值。

# ### 問題
# 在網路上，人們有時會爭論一個有歧義的數學表達式的值，例如 $8 ÷ 2(2+2)$。我們如何在 Python 中寫這個表達式？
# (譯註：這個表達式在網路上常見的爭議是先算 $2(2+2)$ 還是先算 $8÷2$)
#
# - [ ] `8 ÷ 2 (2 + 2)`
# - [ ] `8 / 2 (2 + 2)`
# - [ ] `8 ÷ 2 * (2 + 2)`
# - [X] `8 / 2 * (2 + 2)`
#
# ### 理由
# - 除法的運算子是 `/`，不是 `÷`。此外，Python 中沒有隱含的乘法 —— 你必須使用 `*` 運算子。
# - Python 中沒有隱含的乘法 —— 你必須使用 `*` 運算子。
# - 除法的運算子是 `/`，不是 `÷`。
# - 一個替代方法是把 `8 / 2` 放在括號裡，這樣運算的順序會更清楚，例如 `(8 / 2) * (2 + 2)`。
#   (Python 會依照標準運算子優先順序，從左到右計算 `/` 和 `*`，所以 `8 / 2 * (2 + 2)` 等同於 `(8 / 2) * 4`，即 `4 * 4 = 16`)

# # 標題
# 第二章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 以下哪個是合法的變數名稱？
# - [ ] `2pi`
# - [ ] `question?`
# - [ ] `import`
# - [X] `is_even`
#
#
#
# ### 理由
# - `2pi` 不是合法的變數名稱，因為它以數字開頭。
# - `question?` 不是合法的變數名稱，因為只允許字母、數字和底線符號 `_`。
# - `import` 不是合法的變數名稱，因為它是 Python 的關鍵字之一。
# - `is_even` 是合法的變數名稱，因為允許字母、數字和底線符號 `_`。

# ### 問題
# 以下哪個 *不是* 計算 `2` 的三次方 (2<sup>3</sup>) 的正確方法？
# - [ ] `2 * 2 * 2`
# - [ ] `2 ** 3`
# - [ ] `math.pow(2, 3)` (需要先 `import math`)
# - [X] `2 ^ 3`
#
# ### 理由
# - 乘法是計算 `2` 的三次方的正確方法。
# - 次方運算子 `**` 是計算 `2` 的三次方的正確方法。
# - `math` 模組中的 `pow` 函數是計算 `2` 的三次方的正確方法。
# - 在某些語言中，`^` 運算子用於次方運算，但在 Python 中它代表位元 XOR (互斥或) 運算。

# ### 問題
# 當你呼叫一個函數時，出現在括號中的值是什麼？
# - [ ] assignments (賦值)
# - [ ] comments (註解)
# - [ ] exceptions (例外/異常)
# - [X] arguments (引數/參數)
#
#
# ### 理由
# - 賦值是一個將值指派給變數的陳述式。
# - 註解是你加到程式中用來解釋它如何運作的文字。
# - 例外/異常是程式執行時偵測到的錯誤。
# - 你傳遞給函數的值稱為引數。

# ### 問題
# 如果一個程式執行時沒有產生錯誤訊息，但它沒有做正確的事情，那是哪種類型的錯誤？
# - [ ] syntax error (語法錯誤)
# - [ ] runtime error (執行期錯誤)
# - [ ] exception (例外/異常)
# - [X] semantic error (語義錯誤)
#
#
# ### 理由
# - 語法錯誤會產生錯誤訊息。
# - 執行期錯誤會產生錯誤訊息。
# - 例外/異常會產生錯誤訊息 (例外是執行期錯誤的一種)。
# - 語義錯誤是指程式可以執行，但做的事情是錯誤的。

# # 標題
# 第三章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 當你定義一個函數時，出現在括號中的變數是什麼？
# - [ ] arguments (引數)
# - [ ] local variables (區域變數)
# - [ ] function objects (函數物件)
# - [X] parameters (參數)
#
#
#
# ### 理由
# - 引數是你呼叫函數時提供的值。
# - 區域變數是在函數內部被賦值的變數。
# - 函數物件是定義新函數的結果。
# - 參數是在函數被呼叫時獲得值的變數。

# ### 問題
# 哪種類型的陳述式可以用來多次執行一行程式碼？
# - [ ] assignment statement (賦值陳述式)
# - [ ] import statement (匯入陳述式)
# - [ ] print statement (印出陳述式)
# - [X] `for` statement (`for` 陳述式)
#
#
# ### 理由
# - 賦值陳述式將值指派給變數。
# - 匯入陳述式使得可以使用模組中的函數。
# - 印出陳述式顯示表達式的值。
# - `for` 陳述式可以多次執行一行或多行程式碼。

# ### 問題
# 這個函數有什麼問題嗎 (如果有的話)？
#
# ```python
# def bottle_line(n, suffix):
#     print(n)
#     print('bottles of beer') # 幾瓶啤酒
#     print(suffix)
# ```
#
# - [ ] 第一個字應該是 `define` 而不是 `def`。
# - [ ] 括號中不能有多於一個參數。
# - [ ] 只有主體的第一個陳述式應該縮排。
# - [X] 這個函數沒有錯誤。
#
#
# ### 理由
# - `def` 是定義新函數的正確關鍵字，雖然其他一些語言使用 `define`。
# - 括號中可以有任意數量的參數，包括零個。
# - 函數主體中的所有陳述式都應該縮排。
# - 這個函數沒有任何問題。

# # 標題
# 第四章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 這個函數有什麼問題嗎 (如果有的話)？ (假設 forward 和 left 函數已定義)
#
# ```python
# def square(length): # 正方形
#     for i in range(4):
#         forward(50) # 前進
#         left(90)    # 左轉
# ```
#
# - [ ] `for` 迴圈中陳述式的縮排不正確。
# - [ ] 它沒有把海龜 (Turtle) 帶回起始點。
# - [ ] 這個函數沒有錯誤。
# - [X] 它總是畫出相同大小的正方形，不管 `length` 參數是什麼。
#
#
# ### 理由
# - 這個函數的縮排是正確的。
# - 海龜最後會回到起始點，並且朝向相同的方向。
# - 有一個錯誤！
# - 正方形的大小總是 `50` —— `length` 參數的值從未被使用。

# ### 問題
# 把一段可以運作的陳述式放到一個新的函數定義中，這個過程叫做什麼？
# - [ ] generalization (泛化/一般化)
# - [ ] indentation (縮排)
# - [ ] debugging (除錯)
# - [X] encapsulation (封裝)
#
#
# ### 理由
# - 泛化/一般化是指為函數加入參數使其更通用。
# - 把陳述式放到函數定義中時你可能需要縮排它們，但那不是整個過程的名稱。
# - 如果陳述式可以運作，它們就不需要除錯。
# - 封裝是將一系列陳述式轉換成函數定義的過程。

# ### 問題
# 這裡有 `circle` (畫圓) 函數的兩個版本。(假設 polygon 和 arc 函數已定義)
#
# ```python
# def circle_v1(radius): # 版本1
#     circumference = 2 * math.pi * radius # 圓周長
#     n = 30 # 邊數
#     length = circumference / n # 每邊長度
#     polygon(n, length) # 用多邊形近似圓
#
# def circle_v2(radius): # 版本2
#     arc(radius,  360) # 用畫弧形的方式畫圓 (360度)
# ```
#
# 我們可以怎麼說這兩個函數？
#
# - [ ] 它們有相同的實作 (implementation)，但有不同的介面 (interface)。
# - [ ] 它們有相同的介面 *且* 相同的實作。
# - [ ] 它們既沒有相同的介面，也沒有相同的實作。
# - [X] 它們有相同的介面，但有不同的實作。
#
#
# ### 理由
# - 它們接收相同的參數 (`radius`) 並有相同的效果 (畫一個圓)，所以它們有相同的介面 —— 但它們用不同的方式達到效果，所以它們有不同的實作。
# - (同上)
# - (同上)
# - 它們接收相同的參數並有相同的效果，所以它們有相同的介面 —— 但它們用不同的方式達到效果，所以它們有不同的實作。

# # 標題
# 第五章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 這些賦值陳述式的結果是什麼？
#
# ```python
# a = 25 // 10 # 整數除法
# b = 25 % 10  # 取餘數
# ```
# - [ ] `a` 是 `2.5` 且 `b` 是 `5`
# - [ ] `a` 是 `2` 且 `b` 是 `250`
# - [ ] `a` 是 `2.5` 且 `b` 是 `250`
# - [X] `a` 是 `2` 且 `b` 是 `5`
#
#
# ### 理由
# - `//` 運算子執行整數除法，所以 `25 // 10` 是 `2`。
# - `%` 運算子計算除法後的餘數，所以 `25 % 10` 是 `5`。
# - `//` 運算子執行整數除法，所以 `25 // 10` 是 `2`，且 `%` 運算子計算除法後的餘數，所以 `25 % 10` 是 `5`。
# - `//` 運算子執行整數除法，`%` 運算子計算除法後的餘數。

# ### 問題
# 這些陳述式的結果是什麼？
# ```python
# x = 5
# print(x > 5)
# print(x <= 5)
# ```
# - [ ] 它們印出值 `True` 和 `True`
# - [ ] 它們印出值 `True` 和 `False`
# - [ ] 它們印出值 `False` 和 `False`
# - [X] 它們印出值 `False` 和 `True`
#
#
# ### 理由
# - 如果 `x` 是 `5`，`x > 5` 等同於 `5 > 5`，結果是 `False`。
# - 如果 `x` 是 `5`，`x > 5` 等同於 `5 > 5`，結果是 `False`；此外，`x <= 5` 等同於 `5 <= 5`，結果是 `True`。
# - 如果 `x` 是 `5`，`x <= 5` 等同於 `5 <= 5`，結果是 `True`。
# - 如果 `x` 是 `5`，`x > 5` 是 `False`，且 `x <= 5` 是 `True`。

# ### 問題
# 呼叫這個函數的結果是什麼？
# ```python
# def hello():
#     print('hello') # 哈囉
#     hello() # 遞迴呼叫自己
# ```
# - [ ] 它印出 `hello` 一次。
# - [ ] 它永遠印出 `hello`。
# - [ ] 當 `hello` 第一次嘗試呼叫自己時，它會導致錯誤。
# - [X] 它印出 `hello` 很多次，然後導致錯誤。
#
#
# ### 理由
# - 在它印出 `hello` 一次之後，它會呼叫自己，這會印出 `hello` 很多次，然後導致 `RecursionError` (遞迴錯誤)。
# - 在印出 `hello` 很多次之後，它會導致 `RecursionError`。
# - 在印出 `hello` 很多次之後，它會導致 `RecursionError`。
# - 在印出 `hello` 很多次之後，它會導致 `RecursionError` (因為超過了最大遞迴深度)。

# ### 問題
# `or` 是哪種類型的運算子？
# - [ ] arithmetic (算術運算子)
# - [ ] bitwise (位元運算子)
# - [ ] relational (關係運算子)
# - [X] logical (邏輯運算子)
#
#
# ### 理由
# - `or` 是一個邏輯運算子，與 `and` 和 `not` 一樣。
# - (同上)
# - (同上)
# - `or` 是一個邏輯運算子，與 `and` 和 `not` 一樣。

# # 標題
# 第六章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 如果我們用值 `3` 呼叫這個函數，回傳值是什麼？
# (考拉茲猜想 Collatz conjecture 相關函數)
# ```python
# def collatz(x):
#     if x % 2 == 0: # 如果 x 是偶數
#         return x // 2
#     else: # 如果 x 是奇數
#         return x * 3 + 1
# ```
#
# - [ ] `1`
# - [ ] `1.5`
# - [ ] 它會導致錯誤。
# - [X] `10`
#
#
# ### 理由
# - 因為 `3 % 2` 是 `1` (奇數)，所以條件判斷的第二個分支 (else) 會執行。
# - 因為 `3 % 2` 是 `1`，所以第二個分支會執行。此外，因為 `//` 執行整數除法，`3 // 2` 是 `1` (但這與本題無關，因為 x=3 走 else)。
# - 這個函數可以運作。因為 `3 % 2` 是 `1`，所以第二個分支會執行，結果是 `3 * 3 + 1`，也就是 `10`。
# - 因為 `3 % 2` 是 `1`，所以第二個分支會執行，結果是 `3 * 3 + 1`，也就是 `10`。

# ### 問題
# 我們如何稱呼一個不印出任何東西，也沒有回傳值以外任何其他效果的函數？
# - [ ] recursive (遞迴函數)
# - [ ] dead code (無效程式碼/死碼)
# - [ ] incremental (漸進式)
# - [X] pure function (純函數)
#
#
# ### 理由
# - 遞迴函數會呼叫自己，但它可能會印出東西或有其他效果。
# - 無效程式碼/死碼是指永遠無法執行的程式碼，通常是因為它出現在 `return` 陳述式之後。
# - 漸進式開發是一種透過小幅修改和測試來編寫程式的方法。
# - 純函數不印出任何東西，也沒有回傳值以外的任何其他效果。

# ### 問題
# 用 `x=1.5` 和 `y=1.6` 呼叫這個函數的結果是什麼？
#
# ```python
# def is_close(x, y):
#     return abs(x - y) < 0.2 # abs 是絕對值
# ```
# - [ ] 有語法錯誤。
# - [ ] 有執行期錯誤。
# - [ ] `False`
# - [X] `True`
#
#
# ### 理由
# - 函數的語法是正確的。
# - 只要 `x` 和 `y` 的值是數字，函數就是正確的。
# - `1.5` 和 `1.6` 之間的絕對差是 `0.1`，它小於 `0.2`。
# - `1.5` 和 `1.6` 之間的絕對差是 `0.1`，它小於 `0.2`。

# # 標題
# 第七章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 這個函數應該在 `word` 包含 `'A'` 或 `'a'` 時回傳 `True`，否則回傳 `False`。
# 但它不能正常運作 —— 哪裡錯了？
#
# ```python
# def has_a(word):
#     for letter in word.lower(): # 將 word 轉為小寫再遍歷
#         if letter == 'a':
#             return True  # 一旦找到 'a' 就立刻回傳 True
#         else:
#             return False # 錯誤點：如果第一個字母不是 'a'，就立刻回傳 False
#         # 這行 return False 永遠不會執行到，因為前面 if/else 都有 return
#         return False # 這行是死碼 (dead code)
# ```
#
# - [ ] for 陳述式的第一行有語法錯誤。
# - [ ] 它只檢查小寫的 `'a'`，不檢查大寫的 `'A'`。
# - [ ] 如果 `word` 是空字串，它會導致執行期錯誤。
# - [X] 它只檢查 `word` 的第一個字母。
#
#
# ### 理由
# - 函數的語法是正確的。
# - 它使用了 `lower()` 將 `word` 轉換成小寫，所以如果字串中有大寫的 `'A'`，也會被找到。
# - 如果 `word` 是空字串，迴圈主體永遠不會執行，函數會 (因為沒有明確的 return) 隱含地回傳 `None` (如果最後的 `return False` 死碼被移除的話)。但題目中的寫法，如果 `word` 為空，迴圈不執行，然後會執行到最後的 `return False` (如果它不是死碼的話)。但目前的寫法，如果 `word` 為空，迴圈不執行，那到底回傳什麼？實際上，如果 `word` 為空，`for` 迴圈根本不執行，函數會執行到最後一個 `return False` (假設它不是死碼)。但最主要的問題是 if/else 中的 return。
# - 條件判斷的兩個分支都有 `return` 陳述式，所以這個函數在檢查完第一個字母後就會結束。

# ### 問題
# 假設 `x` 已經被賦值，以下哪個是合法的將 `x` 加一 (遞增) 的方法？
# - [ ] `x++`
# - [ ] `x + 1 = x`
# - [ ] `x = +1`
# - [X] `x = x + 1`
#
#
# ### 理由
# - 有些程式語言使用 `++` 運算子來遞增變數，但 Python 沒有。
# - 賦值陳述式的左邊不能是像 `x + 1` 這樣的表達式。
# - 值 `+1` 和 `1` 相同，所以這個陳述式是把值 `1` 指派給 `x`。
# - 這是更新 `x` 值的合法方式。 (也可以用 `x += 1`)

# ### 問題
# 這個函數做什麼？
#
# ```python
# def check(word, letters):
#     for letter_in_word in word.lower(): # 遍歷 word 中的每個字母 (轉小寫)
#         if letter_in_word in letters.lower(): # 如果該字母也存在於 letters (轉小寫) 中
#             return False # 就立刻回傳 False (表示 word 中有 letters 裡的字母)
#     return True # 如果迴圈跑完都沒回傳 False，表示 word 中完全沒有 letters 裡的字母
# ```
# - [ ] 如果 `letters` 中的任何字母出現在 `word` 中，則回傳 `True`。 (這是 `uses_any` 的行為)
# - [ ] 如果 `word` 中的任何字母出現在 `letters` 中，則回傳 `True`。 (同上)
# - [ ] 如果 `word` 中的所有字母都沒有出現在 `letters` 中，則回傳 `True`。 (與選項D等價)
# - [X] 如果 `letters` 中的所有字母都沒有出現在 `word` 中，則回傳 `True`。 (這個描述不對，應該是「如果 word 中沒有出現任何 letters 中的字母，則回傳 True」)
#   (書中原文的答案是 X，但其 Rationale 比較符合 C 或 D 的正確描述)
#
# ### 理由 (修正為符合程式邏輯的解釋)
# - (不對) 它只有在 `word` 中完全沒有 `letters` 中的任何字母時才會回傳 `True`。
# - (不對) 同上。
# - (對) 它只有在 `word` 中完全沒有 `letters` 中的任何字母時才會回傳 `True`。
# - (對，但用詞可以更精確) 它會檢查 `word` 中的每個字母，如果發現有任何一個字母也存在於 `letters` 中，就立刻回傳 `False`。只有當 `word` 中的所有字母都不在 `letters` 中時，迴圈才會正常結束，並回傳 `True`。
#   (書中 Rationales 的翻譯：它只有在遍歷完 `word` 並且沒有找到 `letters` 中的任何字母時，才會結束迴圈並回傳 `True`。)

# # 標題
# 第八章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 這個比較的結果是什麼：`'Orange' < 'apple'`？
# - [ ] `False`
# - [ ] Syntax error (語法錯誤)
# - [ ] Runtime error (執行期錯誤)，因為你不能比較蘋果和橘子。(雙關語)
# - [X] `True`
#
#
# ### 理由
# - 當我們比較字元時，大寫的 `'O'` 排在小寫的 `'a'` 之前。
# - 語法是正確的。
# - 比較任何兩個字串都是合法的。
# - 因為當我們比較字元時，大寫的 `'O'` 排在小寫的 `'a'` 之前。(Python 的字串比較是基於字元的 Unicode 順序)

# ### 問題
# 假設有一個叫做 `s` 的字串，以下哪個是在它上面調用 `lower` (轉小寫) 方法的正確方式？
# - [ ] `lower(s)`
# - [ ] `string.lower(s)`
# - [ ] `s.lower(string)`
# - [X] `s.lower()`
#
#
# ### 理由
# - `lower` 方法只能使用點記法在一個字串上調用。
# - `lower` 方法只能使用點記法在一個字串上調用。
# - `lower` 方法在括號中不接收參數。
# - 這是調用物件方法的正確語法。

# ### 問題
# 如果我們使用 `re` (正規表示式) 模組中的 `search` 函數，以下哪個字串符合這個模式：`r'ab?c$'`？
# (模式解釋：r'' 是原始字串，^a 表示以a開頭(此模式無^)，b? 表示b出現0或1次，c$ 表示以c結尾)
# - [ ] `'ab?c$'`
# - [ ] `'abcd'`
# - [ ] `'abbc'`
# - [X] `'zac'`
#
#
# ### 理由
# - 問號 `?` 和錢字號 `$` 是改變模式行為的特殊字元 —— 它們不應該出現在要匹配的字串中。
# - 模式 `c$` 要求字串以字母 `c` 結尾。(abcd 不以c結尾)
# - 模式 `b?` 表示 `b` 是可選的 (出現0或1次)，但它不能重複。(abbc 中 b 出現兩次)
# - 字串開頭有額外的字母是可以的 (因為模式沒有 `^` 限制開頭)，且 `b` 不是必需的。(`zac` 以 ac 結尾，符合 a 後面0個b，然後是c結尾)

# # 標題
# 第九章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 執行這些陳述式後，`t` 的值是什麼？
#
# ```python
# t = [1, 2, 3]
# t.pop(1)    # t 變成 [1, 3] (移除了索引1的元素2)
# t.append(2) # t 變成 [1, 3, 2] (在尾巴加入2)
# t.remove(3) # t 變成 [1, 2] (移除了第一個值為3的元素)
# ```
# - [ ] `[2, 2]`
# - [ ] `[1, 3]`
# - [ ] `[1, 2, 3]`
# - [X] `[1, 2]`
#
#
# ### 理由
# - `t.pop(1)` 移除第二個元素，也就是 `2`。
# - 在 `t.pop(1)` 移除第二個元素後，`t.append(2)` 在列表末尾加入 `2`，然後 `t.remove(3)` 移除 `3`。
# - (同上)
# - `t.pop(1)` 移除第二個元素 (值為2)。`t.append(2)` 在列表末尾加入 `2`。`t.remove(3)` 移除值為 `3` 的元素。

# ### 問題
# 執行這些陳述式後，`b` 的值是什麼？
#
# ```python
# a = [1, 2, 3]
# b = a        # 現在 a 和 b 指向同一個列表物件
# a.remove(2)  # 修改了 a 指向的列表，變成 [1, 3]
# ```
# - [ ] `[1, 2]`
# - [ ] `[1, 2, 3]`
# - [ ] Runtime error (執行期錯誤)
# - [X] `[1, 3]`
#
#
# ### 理由
# - `a.remove(2)` 從列表中移除了值 `2`。
# - `a` 和 `b` 參照同一個物件，所以當我們修改 `a` 時，`b` 的值也會改變。
# - 這些陳述式執行時不會導致錯誤。
# - `a` 和 `b` 參照同一個物件，所以當我們修改 `a` 時，`b` 的值也會改變。

# ### 問題
# 對於像這樣建立的兩個列表，我們可以怎麼說：
#
# ```python
# a = [1, 2, 3]
# b = [1, 2, 3]
# ```
#
#
# - [ ] 它們是等值的 (equivalent) 且同一的 (identical)。
# - [ ] 它們是同一的但非等值的。
# - [ ] 它們既非等值的也非同一的。
# - [X] 它們是等值的但非同一的。
#
#
# ### 理由
# - `a` 和 `b` 參照不同的列表物件，所以它們不是同一的。
# - `a` 和 `b` 參照的列表具有相同的值，所以它們是等值的，但它們參照不同的列表物件，所以它們不是同一的。
# - (同上)
# - `a` 和 `b` 參照的列表具有相同的值 (內容相同)，所以它們是等值的。但它們是兩個在記憶體中不同的列表物件，所以它們不是同一的。

# # 標題
# 第十章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 這些陳述式執行後，字典 `d` 的值是什麼？
#
# ```python
# d = {'a': 1, 'b': 2}
# d['a'] = 3 # 更新鍵 'a' 對應的值
# ```
#
# - [ ] `{'a': 1, 'b': 2, 'a': 3}` (字典的鍵是唯一的)
# - [ ] `{'a': 1, 'b': 2}`
# - [ ] 這些陳述式會導致執行期錯誤
# - [X] `{'a': 3, 'b': 2}`
#
# ### 理由
# - 字典中的每個鍵只能出現一次。
# - 第二個賦值陳述式改變了與鍵 `'a'` 相關聯的值。
# - 這段程式碼執行時不會導致錯誤。
# - 第二個賦值陳述式更新了與鍵 `'a'` 相關聯的值。

# ### 問題
# 執行這些陳述式後，字典 `d` 的值是什麼？
#
# ```python
# d = {'a': 1, 'b': 2}
# d['c'] += 1 # 試圖對一個不存在的鍵 'c' 執行 += 1
# ```
#
# - [ ] `{'a': 1, 'b': 2}`
# - [ ] `{'a': 1, 'b': 2, 'c': 1}`
# - [ ] `{'a': 1, 'b': 2, 'c': 3}`
# - [X] 這些陳述式會導致執行期錯誤。
#
#
# ### 理由
# - `+=` 運算子在加 `1` 之前會先查詢鍵以取得舊值。
# - (同上)
# - (同上)
# - 因為 `'c'` 沒有作為鍵出現在字典中，所以第二個陳述式會導致 `KeyError` (鍵錯誤)。

# ### 問題
# 下列陳述式執行時會發生什麼？
#
# ```python
# d1 = {'a': 1, 'b': 2}
# d2 = {d1: 3} # 試圖用字典 d1 作為另一個字典 d2 的鍵
# ```
#
# - [ ] 它們會把 `d1` 當作鍵加入到 `d2` 中。(書中原文是 d3，應為 d2)
# - [ ] 它們會導致 `KeyError`，因為 `d1` 不在 `d2` 中。
# - [ ] 它們會導致 `ValueError`，因為 `3` 不能作為字典中的值。
# - [X] 它們會導致 `TypeError`，因為字典不能作為字典的鍵。
#
#
# ### 理由
# - 字典是可變的 (mutable)，所以它們不是可雜湊的 (hashable)，因此不能作為字典的鍵。
# - (同上，但錯誤類型不是 KeyError)
# - (同上，但錯誤類型不是 ValueError，且3可以作為值)
# - 字典是可變的，所以它們不是可雜湊的，因此不能作為字典的鍵。

# # 標題
# 第十一章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 以下哪個表達式 *不是* 一個元組 (tuple)？
# - [ ] `tuple('abc')` # ('a', 'b', 'c')
# - [ ] `'abc',`       # ('abc',)
# - [ ] `('abc',)`      # ('abc',)
# - [X] `('abc')`       # 這只是一個被括號包起來的字串 'abc'
#
#
# ### 理由
# - 這個表達式的值是一個包含元素 `'a'`、`'b'` 和 `'c'` 的元組。
# - 因為結尾有逗號，這個表達式的值是一個只包含一個元素 `'abc'` 的元組。
# - 因為有逗號，這個表達式的值是一個只包含一個元素 `'abc'` 的元組。括號不是必需的 (但通常會加)。
# - 單獨的括號不會形成元組，所以這個表達式的值只是字串 `'abc'`。

# ### 問題
# 這些陳述式的結果是什麼？
#
# ```python
# t = tuple('abc') # t 是 ('a', 'b', 'c')
# s = [1, 2, 3]    # s 是一個列表
# d = {t: s}       # 用元組 t 作為鍵，列表 s 作為值，建立字典 d
# ```
#
# - [ ] `TypeError`，因為元組不能作為字典的鍵。
# - [ ] `TypeError`，因為列表不能作為字典的值。
# - [ ] Syntax error (語法錯誤)，因為第三行的右大括號前應該有逗號。
# - [X] 一個包含一個項目的字典，該項目從一個元組對應到一個列表。
#
#
# ### 理由
# - 元組是不可變的，所以它可以作為字典的鍵 —— 只要它的元素也都是不可變的 (這裡的字元是不可變的)。
# - 任何型別都可以作為字典中的值，包括列表。
# - 語法是正確的 —— 如果字典中只有一個項目，逗號是合法的但非必需的。
# - 這些陳述式建立了一個包含一個項目的字典，該項目從一個元組對應到一個列表。

# ### 問題
# 這個函數做什麼？
#
# ```python
# def printall(*args): # *args 會把所有傳入的位置引數打包成一個元組 args
#     for value in reversed(args): # reversed(args) 回傳一個反向迭代器
#         print(value)
# ```
# - [ ] 它有語法錯誤，因為 `*` 運算子不能用在參數前。
# - [ ] 它會導致 `TypeError`，因為 `args` 是一個元組，元組是不可變的且不能被反轉。
# - [ ] 它接收一個單一的列表或元組，並按相反順序印出其中的值。
# - [X] 它接收任意數量的引數，並按相反順序印出它們。
#
#
# ### 理由
# - 當 `*` 運算子出現在參數前時，它會把任意數量的引數「打包」到一個元組中。
# - `args` 的確是一個不可變的元組，但 `reversed()` 不會修改元組，它會建立一個新的物件來反向遍歷元組。
# - 這個函數可以接收任意數量的引數，而不只是一個單一的引數。
# - 它接收任意數量的引數並把它們「打包」到一個元組中，然後按相反順序遍歷該元組並印出元素。

# ### 問題
# 這個表達式的值是什麼？
#
# ```python
# ('a', 3) < ('b', 1)
# ```
#
# - [ ] `False`，因為 `3` 大於 `1`。
# - [ ] 這些值無法比較，因為 `'a'` 小於 `'b'`，但 `3` 大於 `1`。
# - [ ] `TypeError`，因為 `<` 運算子不適用於元組。
# - [X] `True`，因為 `'a'` 小於 `'b'`。
#
# ### 理由
# - 當比較元組時，會先比較第一個元素。只有在第一個元素相同時才會比較後續的元素。
# - (同上)
# - `<` 運算子會比較每個元組的第一個元素，然後在第一個元素相同的情況下比較後續元素。
# - 當比較元組時，會先比較第一個元素。因為 'a' < 'b'，所以結果是 True，不會再比較 3 和 1。

# # 標題
# 第十二章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 假設 `t` 是一個字串列表，下面這行程式碼做什麼？
# ```python
# sorted(t, key=len)
# ```
#
# - [ ] 修改 `t` 並按字母順序排序元素。
# - [ ] 建立一個新的列表，其中包含按字母順序排列的元素。
# - [ ] 修改 `t` 並按從短到長的順序排序元素。
# - [X] 建立一個新的列表，其中包含按從短到長的順序排列的元素。
#
#
# ### 理由
# - `sorted()` 建立一個新的列表 —— 它不修改 `t` —— 且 `key=len` 會按從短到長的順序排序元素。
# - 使用 `key=len`，`sorted()` 會按從短到長的順序排序元素。
# - `sorted()` 建立一個新的列表 —— 它不修改 `t`。
# - `sorted()` 建立一個新的列表，且 `key=len` 會按元素的長度 (從短到長) 排序元素。

# ### 問題
# 執行這個程式的效果是什麼？(假設 filename 和 split_line 已定義)
#
# ```python
# word_counter = {}
# for line in open(filename):
#     for word in split_line(line):
#         word_counter[word] += 1 # 試圖對可能不存在的鍵執行 +=
# ```
# - [ ] 它建立一個字典，把每個單字對應到它出現的次數。
# - [ ] 它有語法錯誤，因為縮排不正確。
# - [ ] 它有語義錯誤，因為 `word_counter` 中的所有鍵都對應到值 `1`。
# - [X] 當它試圖遞增 `word_counter` 中的一個值時，會導致 `KeyError`。
#
#
# ### 理由
# - 因為 `word_counter` 一開始是空的，所以當程式試圖遞增 `word_counter` 中的一個值時 (對一個不存在的鍵)，會導致 `KeyError`。
# - 縮排是正確的，但程式會導致 `KeyError`。
# - (同選項A的理由)
# - 因為 `word_counter` 一開始是空的，所以當它第一次遇到一個單字並試圖執行 `word_counter[word] += 1` (等同於 `word_counter[word] = word_counter[word] + 1`) 時，由於 `word_counter[word]` 不存在，會引發 `KeyError`。

# ### 問題
#
# 如果我們執行下列程式碼，結果是 `'a'` 的機率是多少？
# (假設 random.choices 已匯入)
# ```python
# letters = ['a', 'b', 'c']
# weights = [1, 2, 3] # 'a'的權重是1, 'b'是2, 'c'是3
# random.choices(letters, weights=weights) # random.choices 回傳一個列表
# ```
#
# - [ ] 1/3 (三分之一)
# - [ ] 1/4 (四分之一)
# - [ ] 1/5 (五分之一)
# - [X] 1/6 (六分之一)
#
#
# ### 理由
# - 與 `'a'` 相關的權重是 `1`，權重總和是 `1+2+3 = 6`。
# - (同上)
# - (同上)
# - 與 `'a'` 相關的權重是 `1`，權重總和是 `6`，所以選擇 `'a'` 的機率是 `1/6`。

# # 標題
# 第十三章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 如果目前工作目錄是 `/home/dinsdale/photos`，並且你用相對路徑 `mar-2023/photo1.jpg` 開啟一個檔案，
# 以下哪個表達式會計算出被開啟檔案的絕對路徑？
# - [ ] `''.join('/home/dinsdale/photos', 'mar-2023/photo1.jpg')` (join 用法錯誤)
# - [ ] `'mar-2023/photo1.jpg' + '/home/dinsdale/photos'` (順序錯誤且沒有路徑分隔符)
# - [ ] `'/home/dinsdale/photos' + 'mar-2023/photo1.jpg'` (沒有路徑分隔符)
# - [X] `os.path.join('/home/dinsdale/photos', 'mar-2023/photo1.jpg')` (假設 os 已匯入)
#
#
# ### 理由
# - 這種使用字串 `join` 方法的方式不會在路徑的目錄之間加上斜線。
# - 工作目錄和相對路徑的順序反了。此外，這種字串串接方式不會在路徑的目錄之間加上斜線。
# - 這種字串串接方式不會在路徑的目錄之間加上斜線。
# - `os.path.join` 函數會根據執行的作業系統，用正斜線或反斜線連接兩個路徑。

# ### 問題
# 這些陳述式執行後，`s` 的值是什麼？
#
# ```python
# x = 1
# t = 1, # t 是一個單元素元組 (1,)
# s = f'x is an int, {x}. t is a tuple, {t}' # f-string
# ```
#
# - [ ] 這是一個錯誤，因為 `{x}` 和 `{t}` 不是有效的字典。
# - [ ] 這是一個錯誤，因為元組不能作為 f-字串中的值。
# - [ ] `'x is an int, {x}. t is a tuple, {t}'` (如果沒有 f 前綴，結果會是這樣)
# - [X] `'x is an int, 1. t is a tuple, (1,)'`
#
#
# ### 理由
# - `{x}` 和 `{t}` 不是字典 —— 大括號表示它們是會被其值的字串表示法取代的表達式。
# - 任何有效的表達式都可以用在 f-字串中。
# - 在 f-字串內部，大括號中的表達式會被其值的字串表示法取代。
# - 在 f-字串內部，大括號中的表達式會被其值的字串表示法取代。

# ### 問題
#
# 這些陳述式執行後，`db[key]` 的值是什麼？ (假設 shelve 已匯入並可運作)
#
# ```python
# import shelve # 假設
# db = shelve.open('anagram_map_quiz.db', 'n') # 'n' 會建立新檔或清空舊檔
# key = 'opst'
# db[key] = [] # 在 shelf 中，鍵 'opst' 對應到一個空列表
# db[key].append('stop') # 這裡有問題！
# # 上一行是取出 db[key] (一個列表的副本或參照，取決於 shelve 實作)，
# # 然後對這個副本/參照執行 append。這個修改不一定會自動寫回 shelf。
# # 正確更新 shelf 的方式是：
# # temp_list = db[key]
# # temp_list.append('stop')
# # db[key] = temp_list
# retrieved_value = db[key] # 再次從 shelf 讀取
# db.close()
# # os.remove('anagram_map_quiz.db') # 清理測試檔案 (如果需要)
# ```
#
# - [ ] `['stop']`
# - [ ] `'stop'`
# - [ ] `[], 'stop'`
# - [X] `[]`
#
#
# ### 理由
# - `append` 方法在這裡沒有如預期般運作，因為它只修改了記憶體中的列表，而不是資料庫中的那個。
# - (同上)
# - (同上)
# - `append` 方法在這裡沒有如預期般運作，因為它只修改了記憶體中的列表 (從 shelf 讀取出來的那個)，而不是資料庫 (shelf) 中儲存的那個列表。要更新 shelf，你需要把修改後的列表重新賦值給 shelf 中的鍵。

# # 標題
# 第十四章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 要建立一個程式設計師自訂型別的實體，以下哪個步驟順序是正確的？
# - [ ] 賦值給屬性，定義類別，實體化物件。
# - [ ] 實體化物件，定義類別，賦值給屬性。
# - [ ] 定義類別，賦值給屬性，實體化物件。
# - [X] 定義類別，實體化物件，賦值給屬性。
#
#
# ### 理由
# - 你不能在實體化物件之前賦值給屬性。
# - 你不能在定義其類別之前實體化物件。
# - 你不能在實體化物件之前賦值給屬性。
# - 你必須依序：定義類別，實體化物件，然後賦值給屬性。

# ### 問題
#
# 這些陳述式旨在定義一個 `Date` 類別並建立一個 `Date` 物件。它們有什麼問題？
#
# ```python
# def Date: # 錯誤點：應該用 class 關鍵字
#     """Represents a day of the year.""" # 表示一年中的某一天
#
# date = Date()
# date.year = 2024
# date.month = 'January' # 一月
# date.day = 11
# ```
#
# - [ ] 你不能同時有一個名為 `Date` 的類別和一個名為 `date` 的變數。
# - [ ] 所有的屬性必須具有相同的型別。
# - [ ] 將屬性加入到物件的語法不正確。
# - [X] 類別定義必須以 `class` 開頭，而不是 `def`。
#
#
# ### 理由
# - 類別名稱和變數名稱相同 (但大小寫不同) 是合法的 —— 且常見的，類別名稱通常大寫開頭。
# - 物件的屬性可以是任何型別，而且它們不必相同。
# - 點記法是用來設定屬性值和讀取屬性值的。
# - 類別定義必須以 `class` 開頭。函數定義以 `def` 開頭。

# ### 問題
# 以下哪個是對這個函數的正確描述？你可以假設 `date` 是一個具有 `day` 屬性的 `Date` 物件。
#
# ```python
# def increment_day(date):
#     date.day += 1 # 修改了傳入物件的屬性
#     return date   # 回傳了修改後的物件的參照
# ```
#
# - [ ] 它是一個純函數 (pure function)，回傳 `None`。
# - [ ] 它是一個非純函數 (impure function)，回傳 `None`。
# - [ ] 它是一個純函數，回傳一個 `Date` 物件。
# - [X] 它是一個非純函數，回傳一個 `Date` 物件。
#
#
# ### 理由
# - 這個函數修改了它作為參數接收的 `Date` 物件的一個屬性，所以它是一個非純函數。並且它回傳對同一個物件的參照，而不是 `None`。
# - 這個函數回傳對一個 `Date` 物件的參照，而不是 `None`。
# - 這個函數修改了它作為參數接收的 `Date` 物件的一個屬性，所以它是一個非純函數。
# - 這個函數修改了它作為參數接收的 `Date` 物件的一個屬性，所以它是一個非純函數 —— 並且它回傳對同一個 `Date` 物件的參照。

# # 標題
# 第十五章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 假設 `time` 是一個 `Time` 物件，而 `increment` 是在 `Time` 類別中定義的一個實體方法。
# 當我們像這樣調用 `increment` 時會發生什麼？
#
# ```python
# time.increment(42)
# ```
#
# - [ ] `42` 被指派給方法的第一個參數，`time` 被指派給第二個。
# - [ ] 這是一個錯誤，因為 `increment` 需要一個引數，卻提供了兩個。
# - [ ] 這是一個錯誤，因為 `increment` 需要兩個引數，卻只提供了一個。
# - [X] `time` 被指派給方法的第一個參數 (通常是 `self`)，`42` 被指派給第二個。
#
#
# ### 理由
# - `time` (呼叫方法的物件) 被指派給方法的第一個參數。
# - 這個方法需要兩個參數 —— `time` 是第一個 (隱含傳遞給 `self`)，`42` 是第二個。
# - 括號中只出現一個引數，但 `time` (呼叫者) 會作為第一個引數傳遞給 `increment`。
# - `time` 被指派給方法的第一個參數，這個參數依照慣例叫做 `self`，而 `42` 被指派給第二個參數。

# ### 問題
# 假設 `time` 是一個 `Time` 物件 (雖然在此例中未使用)，而 `int_to_time` 是在 `Time` 類別中定義的一個靜態方法。
# 當我們像這樣調用 `int_to_time` 時會發生什麼？
#
# ```python
# start = Time.int_to_time(34800)
# ```
#
# - [ ] 這是一個錯誤，因為 `int_to_time` 需要一個引數，卻提供了兩個。
# - [ ] `Time` 類別物件被指派給方法的第一個參數，`34800` 被指派給第二個。
# - [ ] `34800` 被指派給方法的第一個參數，`Time` 類別物件被指派給第二個。
# - [X] `34800` 被指派給 `int_to_time` 的第一個參數。
#
#
# ### 理由
# - 這裡只有一個引數，就是 `34800`。
# - 因為 `Time` 是一個類別 (用於呼叫靜態方法)，它不會作為引數傳遞給靜態方法的第一個參數 (靜態方法沒有 `self`)。
# - (同上)
# - `34800` 被指派給 `int_to_time` 的第一個參數。因為 `Time` 是一個類別 (用於呼叫靜態方法)，它不會作為引數傳遞。

# ### 問題
# 以下哪個陳述 *不* 正確？
#
# - [ ] 當我們實體化一個物件時，它的 `__init__` 方法會被調用。
# - [ ] 當我們對一個物件使用 `+` 運算子時，它的 `__add__` 方法會被調用 (如果已定義)。
# - [ ] 當我們印出一個物件時，它的 `__str__` 方法會被調用 (如果已定義)。
# - [X] 當我們定義一個新類別時，它的 `__init__` 方法會被調用。
#
#
# ### 理由
# - 這個陳述是正確的。
# - 這個陳述是正確的。
# - 這個陳述是正確的。
# - 定義一個新類別並不會調用它的 `__init__` 方法。`__init__` 是在建立該類別的 *實體* 時被調用的。

# # 標題
# 第十六章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 以下哪個詞是用來描述一個可以與多種類型物件一起運作的函數或方法？
# - [ ] pure (純的)
# - [ ] equivalent (等值的)
# - [ ] static (靜態的)
# - [X] polymorphic (多型的)
#
#
# ### 理由
# - 純函數或方法不修改參數或產生其他副作用。
# - 如果兩個值被認為相等，它們就是等值的。
# - 靜態方法是與類別相關聯，而不是與物件實體相關聯。
# - 一個可以與多種類型一起運作的函數稱為多型的。

# ### 問題
#
# 這個類別定義有什麼問題？
#
# ```python
# class Point:
#     """Represents a point in 2-D space.""" # 表示二維空間中的一個點
#
#     def __init__(self, x, y):
#         x = self.x # 錯誤點：賦值方向反了
#         y = self.y # 錯誤點：賦值方向反了
# ```
#
# - [ ] `__init__` 不是一個合法的方法名稱，因為它不以字母開頭。
# - [ ] 三引號字串必須在方法定義內部。
# - [ ] 方法的第一個參數應該叫做 `point`，而不是 `self`。
# - [X] 賦值陳述式的方向應該相反，例如 `self.x = x` 和 `self.y = y`。
#
#
# ### 理由
# - 像 `__init__` 這樣的特殊方法的名稱以兩個底線字元開頭和結尾。
# - 類別定義內部的三引號字串是文件字串 (docstring)，提供關於類別的資訊。
# - 方法的第一個參數依照慣例命名為 `self`。
# - 賦值陳述式的方向應該相反，例如 `self.x = x` 和 `self.y = y`。

# ### 問題
# 假設我們定義一個 `Line` 類別，使得每個 `Line` 物件有兩個屬性參照 `Point` 物件。
#
# ```python
# class Line:
#     def __init__(self, p1, p2):
#         self.p1 = p1
#         self.p2 = p2
# ```
#
# 如果我們從 `copy` 模組匯入 `copy` 函數，並用它來複製一個 `Line` 物件，以下哪個陳述是正確的？
#
# - [ ] 結果是一個深複製 (deep copy)，它複製了 `Line` 物件和它所包含的 `Point` 物件。
# - [ ] 結果是一個深複製，它複製了 `Line` 物件但沒有複製它所包含的 `Point` 物件。
# - [ ] 結果是一個淺複製 (shallow copy)，它複製了 `Line` 物件和它所包含的 `Point` 物件。
# - [X] 結果是一個淺複製，它複製了 `Line` 物件但沒有複製它所包含的 `Point` 物件。
#
#
# ### 理由
# - `copy` 函數複製了 `Line` 物件，但沒有複製它所包含的 `Point` 物件。
# - `copy` 函數執行的是淺複製。
# - `copy` 函數複製了 `Line` 物件，但沒有複製它所包含的 `Point` 物件。
# - `copy` 函數執行的是淺複製，它複製了 `Line` 物件，但 `Line` 物件的 `p1` 和 `p2` 屬性仍然指向原始的 `Point` 物件 (即 `Point` 物件本身沒有被複製)。

# # 標題
# 第十七章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 以下關於類別變數 (class variables) 的陳述哪個 *不* 正確？
# - [ ] 它們定義在類別定義內部，但不在任何方法定義內部。
# - [ ] 它們可以使用類別物件來存取。
# - [ ] 它們可以是任何型別。
# - [X] 它們是不可變的 (immutable)。
#
#
# ### 理由
# - 類別變數定義在類別定義內部，但不在任何方法定義內部，這是正確的。
# - 類別變數可以使用類別物件來存取，這是正確的。
# - 類別變數可以是任何型別，這是正確的。
# - 這個陳述是錯誤的 —— 也就是說，類別變數是可變的 (除非它們本身是不可變型別，例如數字或字串)。

# ### 問題
# 假設我們像這樣定義一個 `Card` 類別：
#
# ```python
# class Card:
#     def __init__(self, suit, rank):
#         self.suit = suit
#         self.rank = rank
# ```
#
# 如果這個類別沒有提供 `__eq__` 方法，當我們用 `==` 運算子比較兩張牌時會發生什麼？
#
# - [ ] 那是一個錯誤。
# - [ ] 預設情況下，只會比較第一個屬性。
# - [ ] 預設情況下，所有的屬性會像它們在元組中一樣被比較。
# - [X] 預設情況下，只有當物件是同一的 (identical) 時，它們才相等。
#
#
# ### 理由
# - 這不是一個錯誤 —— 如果類別沒有提供 `__eq__`，`==` 運算子有其預設行為。
# - 如果類別沒有提供 `__eq__`，`==` 運算子會檢查物件是否為同一的。
# - (同上)
# - 如果類別沒有提供 `__eq__`，`==` 運算子會檢查物件是否為記憶體中的同一個物件 (同一性)。

# ### 問題
# 當一個類別繼承自另一個類別時，例如：
#
# ```python
# class Hand(Deck): # Hand 繼承自 Deck
#     """Represents a hand of playing cards.""" # 表示一手牌
# ```
# 以下哪個陳述是正確的？
#
# - [ ] `Hand` 是父類別 (parent class)，`Deck` 是子類別 (child class)。
# - [ ] 每個能處理 `Hand` 的函數也應該能處理 `Deck`。
# - [ ] 每個 `Hand` 物件都具有與每個 `Deck` 物件完全相同的屬性，不多也不少。
# - [X] `Deck` 類別中定義的每個方法也可以在 `Hand` 物件上調用 (除非被覆寫)。
#
#
# ### 理由
# - 在這個例子中，`Hand` 繼承自 `Deck`，所以 `Hand` 是子類別，`Deck` 是父類別。
# - 如果 `Hand` 繼承自 `Deck`，它可能會有 `Deck` 沒有的額外方法，所以能處理 `Hand` 的函數不一定能處理 `Deck` (但反過來，能處理 `Deck` 的通常能處理 `Hand`，這是里氏替換原則的體現)。
# - 如果 `Hand` 繼承自 `Deck`，`Hand` 物件應該擁有 `Deck` 物件的所有屬性，但它可以有更多。
# - 如果 `Hand` 繼承自 `Deck`，`Deck` 類別中定義的每個方法 (除非被 `Hand` 覆寫) 都應該適用於 `Hand` 物件。

# ### 問題
# 當一個方法調用另一個方法來完成大部分或全部工作時，我們稱之為什麼？
# - [ ] inheritance (繼承)
# - [ ] generalization (泛化/一般化)
# - [ ] specialization (特化)
# - [X] delegation (委派)
#
#
# ### 理由
# - 繼承是定義一個新類別作為先前定義類別的修改版本的能力。
# - 泛化/一般化是我們為函數加入參數以使其功能更通用的時候。
# - 特化是一種使用繼承來建立新類別的方式，該新類別是現有類別的特化版本。
# - 委派是指一個方法把大部分或全部工作責任傳遞給另一個方法。

# # 標題
# 第十八章
#
# ## 測驗類型
# 形成性測驗

# ### 問題
# 這個運算的結果是什麼？
#
# ```python
# set('abba') <= set('abc')
# ```
# (set('abba') 是 {'a', 'b'}, set('abc') 是 {'a', 'b', 'c'})
#
# - [ ] `False`，因為 `'abba'` 比 `'abc'` 長。
# - [ ] Runtime error (執行期錯誤)，因為 `'abba'` 包含重複元素，所以它不是一個 `set`。
# - [ ] Runtime error (執行期錯誤)，因為字串是不可變的，所以不能轉換成 `set`。
# - [X] `True`，因為 `'abba'` 的元素是 `'abc'` 元素的子集。
#
#
# ### 理由
# - 對於 `set` 物件，`<=` 運算子檢查一個集合是否是另一個集合的子集 —— 它不比較字串的長度。
# - 當集合被建立時，字串中的重複元素會被移除。
# - `set()` 函數會建立一個新的集合 —— 它不會修改字串。
# - 對於 `set` 物件，`<=` 運算子檢查一個集合是否是另一個集合的子集 —— 包含它們相等的可能性。{'a', 'b'} 是 {'a', 'b', 'c'} 的子集。

# ### 問題
# 這些陳述式執行後，`counter` 的值是什麼？
#
# ```python
# from collections import Counter
#
# t = (1, 1, 1, 2, 2, 3)
# counter = Counter(t) # 計算 t 中每個元素出現的次數
# ```
#
# - [ ] `(1, 1, 1, 2, 2, 3)` (這是原始元組)
# - [ ] `{1: 3, 2: 2, 3: 1}` (這是一個字典，Counter 物件類似字典)
# - [ ] `Counter(1, 1, 1, 2, 2, 3)` (Counter 的參數不是這樣用的)
# - [X] `Counter({1: 3, 2: 2, 3: 1})` (這是 Counter 物件的典型表示法)
#
# ### 理由
# - 結果是一個 `Counter` 物件，不是一個元組。
# - 結果是一個 `Counter` 物件，不是一個普通的字典 (儘管行為相似)。
# - 結果是一個 `Counter` 物件，它包含類似字典的項目，而不是一個元組。
# - 結果是一個 `Counter` 物件，它包含列表 (或任何可迭代物件) 中的元素以及每個元素出現的次數。

# ### 問題
# 關於這個類別定義，哪個註解是正確的？
#
# ```python
# class Game:
#     """Represents a game with a dictionary that maps from teams to scores."""
#     # 表示一個遊戲，其中有一個字典將隊伍對應到分數。
#
#     def __init__(self, scores={}): # 預設參數 scores 是一個字典
#         self.scores = scores # 這裡應該是 scores (參數名)，書中原文是 score (可能筆誤)
#                              # 並且，可變預設參數的問題！
# ```
#
# - [ ] 所有 `Game` 物件都參照不同的字典。
# - [ ] 所有 `Game` 物件都參照同一個字典。
# - [ ] 所有使用 `scores` 預設值建立的 `Game` 物件都參照一個空字典。
# - [X] 所有使用 `scores` 預設值建立的 `Game` 物件都參照同一個字典。
#
#
# ### 理由
# - `scores` 的預設值是在函數定義時建立的一個字典。所有使用預設值建立的 `Game` 物件都會獲得對它的參照。
# - 所有使用預設值建立的 `Game` 物件都會獲得對它的參照，但如果一個 `Game` 物件在建立時覆寫了 `scores` (傳入了自己的字典)，它就會參照一個不同的字典。
# - `scores` 的初始值是一個空字典，但之後可能會向其加入項目。
# - 所有使用預設值建立的 `Game` 物件都會獲得對同一個字典的參照 —— 所以如果其中任何一個修改了它，所有其他物件都會看到這個改變。(這是使用可變物件作為預設參數的常見陷阱。)

# ### 問題
#
# 這個表達式的值是什麼？
#
# ```python
# all(number < 10 for number in [2, 4, 6, 8])
# ```
# (檢查 [2,4,6,8] 中的所有數字是否都小於10)
#
# - [ ] `[2, 4, 6, 8]`，其中包含列表中所有小於 `10` 的數字。
# - [ ] Error (錯誤)，因為列表推導式 (list comprehension) 必須在方括號中。
# - [ ] `False`，因為列表中沒有任何數字不小於 `10`。
# - [X] `True`，因為列表中的所有數字都小於 `10`。
#
#
# ### 理由
# - `all()` 函數在序列中的所有元素都為 `True` 時回傳 `True`，否則回傳 `False`。
# - 括號中的表達式是正確的 —— 它是一個生成器表達式 (generator expression)，不是列表推導式。
# - 生成器表達式產生的值都是 `True` (2<10, 4<10, 6<10, 8<10 都是 True)。
# - 生成器表達式產生的值都是 `True`，所以 `all()` 函數的結果是 `True`。

# ### 問題
# 這些陳述式執行後，`d[key]` 的值是什麼，或者是否有錯誤？
#
# ```python
# from collections import defaultdict
#
# d = defaultdict(list) # 當鍵不存在時，預設建立一個空列表
# key = ('into', 'the')
# d[key].append('woods') # d[key] 會回傳一個列表 (如果key不存在則先建立空列表)，然後 append
# ```
#
# - [ ] Error (錯誤)，因為元組不能作為 `defaultdict` 的鍵。
# - [ ] Error (錯誤)，因為我們必須先將鍵加入到 `defaultdict` 中才能查詢它。
# - [ ] `'woods'`
# - [X] `['woods']`
#
#
# ### 理由
# - 元組可以作為 `defaultdict` 的鍵，就像在普通字典中一樣 (只要元組本身是可雜湊的)。
# - 當你查詢一個在這個 `defaultdict` 中尚不存在的鍵時，該鍵會被加入，並以一個新的空列表作為其值。
# - 當鍵被加入到 `defaultdict` 時，對應的值是一個空列表。然後 `append` 方法會向該列表加入一個元素。
# - 當鍵被加入到 `defaultdict` 時，對應的值是一個空列表。在調用 `append` 方法後，該列表包含一個單一元素，即字串 `'woods'`。

# ### 問題
#
# 這個函數執行時會印出什麼值？
#
# ```python
# def pack_and_print(**kwargs): # **kwargs 會收集所有關鍵字引數到一個字典 kwargs 中
#     print(kwargs)
#
# pack_and_print(a=1, b=2)
# ```
#
# - [ ] 這是一個錯誤，因為次方運算子 `**` 不能出現在參數列表中。
# - [ ] `[(a, 1), (b, 2)]` (這是一個元組的列表)
# - [ ] `{'a', 'b'}, [1, 2]` (這是一個集合和一個列表)
# - [X] `{'a': 1, 'b': 2}` (這是一個字典)
#
# ### 理由
# - 在參數列表中，`**` 是打包 (pack) 運算子，不是次方運算子。
# - 打包運算子 `**` 把關鍵字引數打包到一個字典中，而不是一個元組的列表。
# - 打包運算子 `**` 把關鍵字引數打包到一個字典中，而不是一個集合和一個列表。
# - 打包運算子 `**` 把關鍵字引數打包到一個字典中，該字典從關鍵字名稱對應到值。

# (這個儲存格是空的)

# # 標題
# Think Python (總結性測驗)
#
# ## 測驗類型
# 總結性測驗 (Summative)

# ### 問題
# 這個程式的輸出是什麼？
#
# ```python
# s = '3'
# str(s) * int(s) # str('3') 是 '3', int('3') 是 3 => '3' * 3
# ```
#
# - [ ] 整數 `9`
# - [ ] 字串 `'9'`
# - [ ] 整數 `333`
# - [X] 字串 `'333'`
#
#
# ### 理由
# - `str(s)` 是字串 `'3'`，`int(s)` 是整數 `3`。請參見第一章。
# - 將一個字串乘以整數 `3` 會將該字串重複三次。請參見第一章。
# - 當我們將字串乘以整數時，結果是一個字串。請參見第一章。
# - 將一個字串乘以整數 `3` 會將該字串重複三次。請參見第一章。

# ### 問題
# 要讓這個函數運作而不導致錯誤，`n` 的先決條件 (preconditions) 是什麼？
#
# ```python
# def countdown(n): # 倒數計時
#     if n == 0:
#         print('Blastoff!') # 發射！
#     else:
#         print(n)
#         countdown(n-1) # 遞迴呼叫
# ```
#
#
# - [ ] `n` 必須是一個 `float` (浮點數)。
# - [ ] `n` 必須是負數。
# - [ ] `n` 必須是嚴格正數，不能是 `0`。
# - [X] `n` 必須是一個正整數或 `0` (即非負整數)。
#
#
# ### 理由
# - `n` 可以是一個沒有小數部分的 `float`，但它也可以是一個 `int`。請參見第五章。
# - 如果 `n` 是負數，它會一直遞迴直到堆疊達到其極限並導致 `RecursionError`。請參見第五章。
# - 如果 `n` 是 `0`，函數會印出 `'Blastoff!'` 並回傳，而不進行遞迴呼叫。請參見第五章。
# - `n` 必須是非負的 —— 也就是說，正數或 `0`。請參見第五章。

# ### 問題
# 下列程式有什麼問題？
#
# ```python
# def compare(x, y):
#     if x < y:
#         return -1
#     else: # 包含 x == y 和 x > y 的情況
#         return 1
#     # 這行 return 0 永遠不會被執行到，因為上面的 if/else 都有 return
#     return 0 # 這是死碼 (dead code)
# ```
#
# - [ ] 它有語法錯誤，因為最後一行沒有縮排。
# - [ ] 它有執行期錯誤，因為回傳值不能是負數。
# - [ ] 它有語法錯誤，因為它有多於一個 return 陳述式。
# - [X] 它有邏輯錯誤 (logic error)，因為最後一行是死碼。
#
#
# ### 理由
# - 程式的語法是正確的，但有一個錯誤。請參見第六章。
# - 任何值都可以是合法的回傳值 —— 但有一個邏輯錯誤，因為最後一行永遠無法執行。請參見第六章。
# - 程式的語法是正確的，但有一個邏輯錯誤，因為最後一行永遠無法執行。請參見第六章。
# - `if` 陳述式的兩個分支都有 `return` 陳述式，所以最後一行永遠無法執行 —— 它是死碼。請參見第六章。

# ### 問題
# 這個程式的輸出是什麼，或者是否有錯誤？
# ```python
# def rectangle_area(length, width): # 矩形面積
#     return length * width
#
# area = rectangle_area(3, 5) # area 會是 15
# print(length) # 錯誤點：length 是函數內的區域變數，外部無法存取
# ```
# - [ ] `3`，因為第一個引數被指派給 `length`。
# - [ ] `5`，因為第二個引數被指派給 `length`。
# - [ ] Syntax error (語法錯誤)，因為 return 陳述式中有兩個變數。
# - [X] Runtime error (執行期錯誤)，因為參數 `length` 在函數外部不存在。
#
#
# ### 理由
# - `3` 的確被指派給 `length`，但該參數只存在於函數內部。請參見第六章。
# - 第一個引數被指派給 `length`，但該參數只存在於函數內部。請參見第六章。
# - 變數是算術表達式的一部分，可以用在 return 陳述式中 (這裡 `length * width` 是一個表達式)。請參見第六章。
# - 參數和區域變數只存在於它們被定義的函數內部。請參見第六章。

# ### 問題
# 下列程式有什麼問題？
#
# ```python
# s = int('123') # s 是整數 123
# for digit in s: # 錯誤點：不能遍歷一個整數
#     print(digit)
# ```
#
#
# - [ ] 沒有問題 —— 程式是正確的。
# - [ ] `digit` 不是一個合法的迴圈變數名稱。
# - [ ] `int` 是一個型別，不是一個函數。
# - [X] `s` 不是一個序列 (sequence)，所以我們不能遍歷它的元素。
#
#
# ### 理由
# - 這個程式會產生 `TypeError`。請參見第七章。
# - 任何合法的變數名稱都可以用作迴圈變數。請參見第七章。
# - `int` 是一個型別，但它也可以用作函數來將其他型別轉換成整數。請參見第七章。
# - `s` 是一個整數，它不是序列，所以不能被遍歷。請參見第七章。

# ### 問題
# 以下哪個是將字串轉換為小寫的正確方法？ (假設 str_var 是一個字串變數)
#
# - [ ] `lower(str_var)`
# - [ ] `str_var = lower(str_var)`
# - [ ] `str_var.lower()` (這會回傳一個新的小寫字串，但沒有賦值回去)
# - [X] `str_var = str_var.lower()`
#
#
# ### 理由
# - `lower` 是一個方法，所以必須在一個字串上調用，例如 `str_var.lower()`；並且它會建立一個新的字串，應該被指派給一個變數。請參見第七章。
# - `lower` 是一個方法，所以必須在一個字串上調用，例如 `str_var.lower()`。請參見第七章。
# - `str_var.lower()` 會建立一個新的字串，但如果這個字串沒有被指派給一個變數，就無法存取它。請參見第七章。
# - `str_var.lower()` 會建立一個新的字串 —— 如果我們把它重新指派給 `str_var`，新的字串就會取代舊的。請參見第七章。

# ### 問題
# 下列函數接收兩個字串作為參數並回傳一個字串。
# 以下哪個文件字串 (docstring) 是對這個函數功能的正確描述？
#
# ```python
# def compute(word1, word2):
#     t = []
#     for letter in word1: # 遍歷 word1 中的每個字母
#         if letter in word2: # 如果該字母也存在於 word2 中
#             t.append(letter) # 就把它加到列表 t
#     return ''.join(t) # 把列表 t 中的字母串接起來回傳
# ```
#
# - [ ] 回傳出現在 `word1` 或 `word2` 或兩者之中的字母。(這是聯集)
# - [ ] 回傳出現在 `word1` 或 `word2` 但非兩者皆有的字母。(這是對稱差集)
# - [ ] 回傳出現在 `word1` 但不在 `word2` 中的字母。(這是差集 word1 - word2)
# - [X] 回傳同時出現在 `word1` 和 `word2` 中的字母 (依照它們在 `word1` 中的順序和次數)。(這是交集，但保留順序和重複)
#
#
# ### 理由
# - 要進入 `append` 方法，`letter` 必須同時出現在兩個單字中。請參見第七章。
# - (同上)
# - (同上)
# - 這個函數回傳一個字串，其中包含同時出現在 `word1` 和 `word2` 中的字母 (依照它們在 `word1` 中出現的順序和次數)。請參見第七章。

# ### 問題
# 這個函數旨在將單字的第一個字母轉為小寫，其餘字母轉為大寫。
#
# ```python
# def lower_upper(word):
#     first = word[0]       # 取得第一個字母
#     rest = word[1:]       # 取得從第二個字母開始的其餘部分
#     word = first.lower() + rest.upper() # 區域變數 word 被修改
#     # 沒有 return 陳述式
# ```
#
# 如果我們像這樣呼叫這個函數，`word` (呼叫端的 word) 的值是什麼 —— 或者是否有錯誤？
#
# ```python
# word = 'Python' # 呼叫端的 word
# word = lower_upper(word) # 呼叫函數並將回傳值賦給呼叫端的 word
# ```
#
# - [ ] 結果是語法錯誤，因為 `:` 字元不能出現在方括號運算子內部。
# - [ ] 結果是執行期錯誤，因為 `0` 不是一個有效的索引。
# - [ ] 程式是正確的 —— `word` 的值是 `'pYTHON'`。
# - [X] 程式包含邏輯錯誤 —— `word` 的值是 `None`。
#
#
# ### 理由
# - 方括號運算子內部的冒號表示切片 (slice) —— 在這個例子中，它選取從第二個到最後的所有字元。請參見第八章。
# - `0` 是一個有效的索引 —— 它選取字串中的第一個字元。請參見第八章。
# - 函數沒有 return 陳述式，所以它回傳 `None`。將新值指派給參數 `word` (函數內的區域變數) 不會影響函數外部的同名變數 (除非函數有回傳值並被重新賦值給外部變數)。請參見第九章。
# - (同上)

# ### 問題
# 如果我們使用 `re` 模組中的 `search` 函數，以下哪個字串符合這個模式：`r'^a(bc|de)f$'`？
# (模式解釋：r'' 原始字串，^a 以a開頭，(bc|de) 匹配bc或de，f$ 以f結尾)
# - [ ] `'abcdef'` (中間是 bcde，不符合 bc 或 de)
# - [ ] `'zadef'` (不以a開頭)
# - [ ] `'abc'` (不以f結尾)
# - [X] `'adef'` (以a開頭，中間是de，以f結尾)
#
#
# ### 理由
# - 模式 `'(bc|de)'` 要求 `'bc'` 或 `'de'`，但不能兩者都有。請參見第八章。
# - 模式 `^a` 要求字串以字母 `a` 開頭。請參見第八章。
# - 模式 `f$` 要求字串以字母 `f` 結尾。請參見第八章。
# - 這個字串開頭是 `'a'`，結尾是 `'f'`，中間是 `'de'`。請參見第八章。

# ### 問題
# 這個程式的結果是什麼？
#
# ```python
# t = [1, 2, 3, 4]
# t[1:-1] # 切片，從索引1到索引-1 (不包含-1)
#         # 索引-1是最後一個元素4，所以是不包含4
#         # 結果是從索引1 (值2) 到索引2 (值3)
# ```
#
# - [ ] `IndexError`，因為 `-1` 不是一個合法的索引。
# - [ ] `[1, 2, 3]`
# - [ ] `[2, 3, 4]`
# - [X] `[2, 3]`
#
#
# ### 理由
# - 負數索引從序列的末尾倒著數，所以切片索引 `1:-1` 選取從第二個元素到倒數第二個元素 (包含兩者，但不包含最後一個)。請參見第九章。
# - 切片索引 `1:-1` 排除了列表的第一個元素。請參見第九章。
# - 切片索引 `1:-1` 排除了列表的最後一個元素。請參見第九章。
# - 切片索引 `1:-1` 選取從第二個元素 (索引1) 到倒數第二個元素 (索引-2，或者說直到索引-1之前)。所以是 `t[1]` 和 `t[2]`。請參見第九章。

# ### 問題
# 這些陳述式執行後，`a` 和 `b` 的值是什麼，或者是否有錯誤？
#
# ```python
# a, b = 1, 2 # a=1, b=2
# a, b = b, a # 交換a和b的值 (右邊先求值 (b,a) -> (2,1)，然後賦值給左邊 (a,b))
# ```
#
# - [ ] 有執行期錯誤，因為右邊的值是元組。
# - [ ] 有語法錯誤，因為賦值陳述式有多於一個變數。
# - [ ] `a` 是 `1` 且 `b` 是 `2`。
# - [X] `a` 是 `2` 且 `b` 是 `1`。
#
#
# ### 理由
# - 右邊的值是元組，但這些是合法的賦值陳述式 (元組賦值)。請參見第十一章。
# - 賦值陳述式的左邊可以是一個變數元組。請參見第十一章。
# - 在第一個賦值之後，`a` 是 `1`，`b` 是 `2`，但第二個賦值交換了它們的值。請參見第十一章。
# - 在第一個賦值之後，`a` 是 `1`，`b` 是 `2`，然後第二個賦值交換了它們的值。請參見第十一章。

# ### 問題
# 為什麼列表不能作為字典的鍵？
#
# - [ ] 列表中的元素可能不是完全有序的 (totally ordered)。
# - [ ] 列表中的元素可以是不同型別。
# - [ ] 列表可以包含任意數量的元素。
# - [X] 列表是可變的 (mutable)，這使得它們不可雜湊 (unhashable)。
#
#
# ### 理由
# - 如果列表的元素不是完全有序的，它們就不可排序，但這不是列表不能作為字典鍵的原因。請參見第十章和第十一章。
# - 列表中的元素可以是不同型別，但這不是列表不能作為字典鍵的原因。請參見第十章和第十一章。
# - 列表可以包含任意數量的元素，但這不是列表不能作為字典鍵的原因。請參見第十章和第十一章。
# - 如果一個物件是可變的，它就不是可雜湊的，這意味著它不能用作字典的鍵。請參見第十章和第十一章。

# ### 問題
# 列表和元組的主要區別是什麼？
#
# - [ ] 列表可以包含任何型別；元組只能包含可雜湊的型別。
# - [ ] 元組可以包含任何型別；列表只能包含可雜湊的型別。
# - [ ] 元組是可變的；列表是不可變的。
# - [X] 列表是可變的；元組是不可變的。
#
#
# ### 理由
# - 列表和元組都可以包含任何型別。字典的鍵必須是可雜湊的。請參見第十一章。
# - (同上)
# - 正好相反：列表是可變的；元組是不可變的。請參見第十一章。
# - 元組是不可變的。請參見第十一章。

# ### 問題
# 以下哪個是就地 (in place) 反轉列表元素的正確方法 —— 也就是說，修改現有列表而不建立新列表？
# (假設 t 是一個列表)
# - [ ] `t = reversed(t)` (reversed 回傳迭代器，list(reversed(t)) 才建新列表)
# - [ ] `reversed(t)` (只建立迭代器，沒改變 t)
# - [ ] `t = t.reverse()` (t.reverse() 就地修改並回傳 None)
# - [X] `t.reverse()`
#
#
# ### 理由
# - 這個陳述式可以運作 (如果後面用 list() 包起來)，但它會建立一個新的列表，並且不會修改 `t` (除非你把新列表賦值回 t)。`reversed()` 本身回傳一個迭代器。請參見第十一章。
# - `reversed(t)` 會建立一個新的反向迭代器，但如果這個迭代器沒有被使用或指派給變數，就無法存取反轉後的序列，且原始列表 `t` 不變。請參見第十一章。
# - `t.reverse()` 的回傳值是 `None`，所以這個陳述式會把 `t` 設為 `None`。請參見第十一章。
# - `t.reverse()` 會就地反轉 `t` 的元素，而不建立新的列表。請參見第十一章。

# ### 問題
# 這個程式的結果是什麼？
#
# ```python
# s = ['bbb', 'aa', 'c']
# sorted(s, key=len, reverse=True) # 建立一個新的排序後列表，但沒有賦值
# # s 本身不會被修改
# # sorted 的結果是按長度降序：['bbb', 'aa', 'c']
# ```
# (題目問的是「結果」，如果是指 sorted() 的回傳值，則是 X。如果是指 s 的值，則 s 不變。)
# (假設題目問的是 sorted() 的回傳值)
# - [ ] `['aa', 'bbb', 'c']`
# - [ ] `['c', 'aa', 'bbb']`
# - [ ] `['c', 'bbb', 'aa']`
# - [X] `['bbb', 'aa', 'c']`
#
#
# ### 理由
# - `key=len` 按長度排序，而不是字母順序，且 `reverse=True` 按降序排序。請參見第十二章。
# - `reverse=True` 按降序排序。請參見第十二章。
# - `key=len` 按長度排序，而不是字母順序。請參見第十二章。
# - `key=len` 按長度排序，而不是字母順序，且 `reverse=True` 按降序排序，所以結果是 `['bbb', 'aa', 'c']`。請參見第十二章。

# ### 問題
# 下列函數做什麼？
# ```python
# def compute(d1, d2):
#     res = {} # 建立一個空字典
#     for key in d1: # 把 d1 的所有鍵值對複製到 res
#         res[key] = d1[key]
#     for key in d2: # 把 d2 的所有鍵值對複製到 res (如果鍵已存在，則 d2 的值會覆蓋 d1 的值)
#         res[key] = d2[key]
#     return res
# ```
#
# - [ ] 將 `d1` 中的鍵加入到 `d2` 中。(函數回傳新字典，不修改 d1, d2)
# - [ ] 將 `d2` 中的鍵加入到 `d1` 中。(同上)
# - [ ] 建立一個新的字典，其中包含所有同時在 `d1` 和 `d2` 中的鍵。(這是交集)
# - [X] 建立一個新的字典，其中包含所有在 `d1` 或 `d2` 中的鍵 (如果鍵相同，則 `d2` 的值優先)。(這是合併，且 d2 優先)
#
#
# ### 理由
# - 這個函數建立並回傳一個新的字典。請參見第十二章。
# - (同上)
# - 新的字典包含來自任一字典的所有鍵。請參見第十二章。
# - 新的字典包含來自任一字典的所有鍵。如果同一個鍵出現在兩個字典中，它會得到來自 `d2` 的值。請參見第十二章。 (這相當於 `res = d1.copy(); res.update(d2)`)

# ### 問題
# 假設我們執行下列程式來取得目前工作目錄：
#
# ```python
# import os
#
# os.getcwd()
# ```
#
# 結果是 `/home/dinsdale/photos`。
# 現在假設我們執行下列程式來檢查檔案是否存在：
#
# ```python
# os.path.exists('apr-2023/photo1.jpg') # 'apr-2023/photo1.jpg' 是相對路徑
# ```
#
# 被檢查檔案的絕對路徑是什麼？
#
# - [ ] `'photo1.jpg'`
# - [ ] `'apr-2023/photo1.jpg'`
# - [ ] `'/home/dinsdale/photo1.jpg'`
# - [X] `'/home/dinsdale/photos/apr-2023/photo1.jpg'`
#
#
# ### 理由
# - 因為 `'apr-2023/photo1.jpg'` 是一個相對路徑，它會被附加到目前工作目錄後面。請參見第十三章。
# - (同上)
# - (同上)
# - 因為 `'apr-2023/photo1.jpg'` 是一個相對路徑，它會被附加到目前工作目錄後面。請參見第十三章。

# ### 問題
# 這個程式的結果是什麼？
# ```python
# class Day:
#     def __init__(self, day_name): # 參數改名
#         self.day = day_name
#
#     def __str__(self): # 參數應為 self (書中原文為 date，不影響功能但非慣例)
#         return f'Today is {self.day}' # 今天是...
#
# print(Day('Wednesday')) # Wednesday (星期三)
# ```
# - [ ] `f'Today is Wednesday'` (f-string 本身不會被印出)
# - [ ] `'Today is {Wednesday}'` (如果 __str__ 這樣寫，且 Wednesday 是變數)
# - [ ] `f'Today is {date.day}'` (這是 __str__ 的定義，不是 print 的輸出)
# - [X] `'Today is Wednesday'`
#
#
# ### 理由
# - 字串前的 `f` 表示它是一個格式化字串 (f-string)。請參見第十五章。
# - 大括號不會出現在回傳值中 (它們標示了要被替換的表達式)。請參見第十五章。
# - 字串前的 `f` 表示它是一個格式化字串，大括號中的表達式會被其值取代。請參見第十五章。
# - 在格式化字串中，大括號中的表達式會被其值取代。請參見第十五章。

# ### 問題
# 假設 `Animal` 類別存在，這個程式的輸出是什麼？
#
# ```python
# class Cat(Animal): # Cat 繼承自 Animal
#     """Represents a cat.""" # 表示一隻貓
#
# cat = Cat()
# isinstance(cat, Animal) # 檢查 cat 是否為 Animal 的實體 (或其子類別的實體)
# ```
#
# - [ ] `False`，因為父類別的實體不是子類別的實體。
# - [ ] `False`，因為子類別的實體不是父類別的實體。
# - [ ] `True`，因為每個父類別的實體也是子類別的實體。
# - [X] `True`，因為每個子類別的實體也是父類別的實體。
#
#
# ### 理由
# - 父類別的實體不是子類別的實體，這是對的，但這裡檢查的是相反的情況。請參見第十七章。
# - 每個子類別的實體也是父類別的實體。請參見第十七章。
# - 父類別的實體不是子類別的實體。請參見第十七章。
# - 在這個例子中，`Cat` 是 `Animal` 的子類別，所以每個 `Cat` 物件也是 `Animal` 的一個實體。請參見第十七章。

# ### 問題
# 這個程式的結果是什麼？
#
# ```python
# from collections import namedtuple
#
# Point = namedtuple('Point', ['x', 'y']) # 建立一個具名元組類別 Point，有屬性 x, y
# p = Point(3, 4) # 建立實體 p，x=3, y=4
# p[1] # 用索引存取具名元組的元素
# ```
#
# - [ ] `AttributeError`，因為 `p` 的屬性是 `x` 和 `y`。
# - [ ] `IndexError`，因為 `p` 的屬性是 `x` 和 `y`。
# - [ ] `3`，因為 `p` 是一個 `namedtuple`，索引為 `1` 的元素是 `3`。
# - [X] `4`，因為 `p` 是一個 `namedtuple`，索引為 `1` 的元素是 `4`。
#
#
# ### 理由
# - `p` 的屬性是 `x` 和 `y`，但因為 `p` 是一個 `namedtuple`，我們可以用方括號運算子透過索引來存取元素。請參見第十八章。
# - (同上)
# - 在具名元組中 —— 如同在普通元組中 —— 第一個元素的索引是 `0`。請參見第十八章。
# - 在具名元組中 —— 如同在普通元組中 —— 第二個元素的索引是 `1`。請參見第十八章。

# ### 問題
# 我們可以像這樣呼叫內建函數 `round`：
#
# ```python
# import math
#
# round(math.pi, ndigits=3) # 將圓周率 pi 四捨五入到小數點後三位
# ```
#
# 結果是 `math.pi` 四捨五入到小數點後三位的值。
# 現在假設我們把位置引數放在一個元組中，把關鍵字引數放在一個字典中，像這樣：
#
# ```python
# import math # 確保 math 已匯入
# args_round = (math.pi,) # 位置引數元組
# kwargs_round = {"ndigits": 3} # 關鍵字引數字典
# ```
#
# 以下哪個是呼叫 `round` 並得到相同結果的正確方式？
#
# - [ ] `round(args_round, kwargs_round)` (這樣會把元組和字典當作兩個獨立的位置引數傳遞)
# - [ ] `round(*args_round, *kwargs_round)` (*kwargs_round 用法錯誤，應該是 **)
# - [ ] `round(**args_round, **kwargs_round)` (**args_round 用法錯誤，應該是 *)
# - [X] `round(*args_round, **kwargs_round)`
#
#
# ### 理由
# - 為了把 `args_round` 的元素作為位置引數傳遞，我們必須用 `*` 運算子解包它們。同樣地，為了把 `kwargs_round` 中的項目作為關鍵字引數傳遞，我們必須用 `**` 運算子解包它們。請參見第十八章。
# - 為了把 `kwargs_round` 中的項目作為關鍵字引數傳遞，我們必須用 `**` 運算子解包它們。請參見第十八章。
# - 為了把 `args_round` 的元素作為位置引數傳遞，我們必須用 `*` 運算子解包它們。請參見第十八章。
# - `*` 運算子解包 `args_round` 的元素，`**` 運算子解包 `kwargs_round` 中的項目。請參見第十八章。

# ### 問題 (這個儲存格在原始 .py 中是空的，通常是為了一個新的、未完成的問題預留的)
# - [ ]
# - [ ]
# - [ ]
# - [X] (假設這是個預留問題的正確答案標記)
#
#
# ### 理由
# -
# -
# -
# -